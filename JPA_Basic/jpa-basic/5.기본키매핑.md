# 기본 키 매핑
[기본 키 매핑 방법](#기본-키-매핑-방법)
[SEQUENCE - @SequenceGenerator](#sequence---sequencegenerator)
[TABLE 전략](#table-전략)
[권장하는 식별자 전략](#권장하는-식별자-전략)
[IDENTITY 전략 - 특징](#identity-전략---특징)
[SEQUENCE 전략 - 매핑](#sequence-전략---매핑)
[allocationSize](#allocationsize)

### 기본 키 매핑 방법
직접 할당 : @Id만 사용
자동 생성(@GeneratedValue) - @GeneratedValue(strategy = GenerationType.AUTO)
    - IDENTITY : 데이터베이스에 위임, MYSQL
    - SEQUENCE : 데이터베이스 시퀀스 오브젝트 사용, ORACLE
        @SequenceGenerator 필요
    - TABLE : 키 생성용 테이블 사용, 모든 DB 에서 사용
        @TableGenerator 필요
    - AUTO : 방언에 따라 자동 지정
* Id 값을 String 타입으로 하면 안된다. Long 타입이 맞다.
int는 0, Integer는 10몇억 밖에 안된다.


### SEQUENCE - @SequenceGenerator

```java
@Entity
@SequenceGenerator(
          name = "MEMBER_SEQ_GENERATOR"
        , sequenceName = "MEMBER_SEQ"   // 매핑할 데이터베이스 시퀀스 이름
        , initialValue = 1
        , allocationSize = 1
)
public class Member {
    @Id
    @GeneratedValue(
            strategy = GenerationType.IDENTITY
            , generator = "MEMBER_SEQ_GENERATOR"
    )
    private Long id;
}
```
Hibernate: create sequence MEMBER_SEQ start with 1 increment by 1

| 속성              | 설명                                                                                           | 기본값                |
|-----------------|----------------------------------------------------------------------------------------------|--------------------|
| name            | 식별자 생성기 이름                                                                                   | 필수                 |
| sequenceName    | 데이터베이스에 등록되어 있는 시퀀스 이름                                                                       | hibernate_sequence |
| initialValue    | DDL 생성 시에만 사용됨, 시퀀스 DDL을 생성할 때 처음 1 시작하는 수를 지정한다.                                            | 1                  |
| allocationSize  | 시퀀스 한 번 호출에 증가하는 수(성능 최적화에 사용됨)<br/>데이터베이스 시퀀스 값이<br/>하나씩 증가하도록 설정되어 있으면 이 값을 반드시 1로 설정해야한다. | 50                 |
| catalog, schema | 데이터베이스 catalog, schema 이름                                                                    | 테스트3               |

### TABLE 전략
키 생성 전용 테이블을 하나 만들어 데이터베이스 시퀀스를 흉내내는 전략
장점 : 모든 데이터베이스에 적용 가능
단점 : 성능

```java
@Entity
@TableGenerator(
          name = "MEMBER_SEQ_GENERATOR"
        , table = "MY_SEQUENCES"   // 매핑할 데이터베이스 시퀀스 이름
        , pkColumnValue = "MEMBER_SEQ"
        , allocationSize = 1
)
public class Member {
    @Id
    @GeneratedValue(
            strategy = GenerationType.TABLE
            , generator = "MEMBER_SEQ_GENERATOR"
    )
    private Long id;
}
```
Hibernate:

    create table MY_SEQUENCES (
       sequence_name varchar(255) not null,
        next_val bigint,
        primary key (sequence_name)
    )
SELECT * FROM MY_SEQUENCES

SEQUENCE_NAME  	NEXT_VAL  
MEMBER_SEQ	1

TABLE 매핑 전략은 잘 사용하지 않는다.

### 권장하는 식별자 전략
기본 키 제약 조건 : null 아님, 유일, 변하면 안된다.
미래까지 이 조건을 만족하는 자연 키(비즈니스와 관련된. 주민등록번호, 휴대폰번호 등)는 찾기 어렵다.
    대리키(대체키, autoIncrement 등 비즈니스와 관련되지 않은 키)를 사용하자
예를 들어 주민등록번호도 기본 키로 적절하지 않다.

*** 권장 : Long 타입 + 대체키 + 키 생성전략 사용 ***

### IDENTITY 전략 - 특징
- 기본 키 생성을 데이터베이스에 위임
- 주로 MYSQL, PostgreSQL, SQL Server, DB2 에서 사용
- (예: MySQL의 AUTO_INCREMENT)
- JPA는 보통 트랜잭션 커밋 시점에 INSERT SQL 실행
- AUTO_INCREMENT는 데이터베이스에 insert sql을 실행한 이후에 ID 값을 알 수 있음
- INDENTITY 전략은 em.persist() 시점에 즉시 insert sql을 실행하고 DB에서 식별자를 조회

IDENTITY 전략은 내가 Id에 값을 넣으면 안된다. 그리고 Insert를 해야한다.
NULL로 넘어가면 그 때 값을 넣어줘야한다.

하지만 영속성 컨텍스트는 1차 캐시에 key값인 @Id가 있어야하는데,
DB에 넘어가야 key값을 알 수 있다.
그래서 @GeneratedValue(strategy = GenerationType.IDENTITY)에서는
commit 시점에서 insert query가 실행되지 않고 em.persist(member) 호출한 시점에서 쿼리가 실행된다.

```java
System.out.println("==========");
em.persist(member);
System.out.println("member Id : " + member.getId());
System.out.println("==========");
```
==========
Hibernate:
    /* insert hellojpa.Member
        */ insert
        into
            Member
            (id, name)
        values
            (default, ?)
member Id : 1
==========

### SEQUENCE 전략 - 매핑

```java
@Entity
@SequenceGenerator(
        name = "MEMBER_SEQ_GENERATOR",
        sequenceName = "MEMBER_SEQ",
        initialValue = 1, allocationSize = 1
)
public class Member {
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE,
            generator = "MEMBER_SEQ_GENERATOR")
    private Long id;
}


Member member = new Member();
member.setUsername("D");

System.out.println("==========");
em.persist(member);
System.out.println("member Id : " + member.getId());
System.out.println("==========");
```
Hibernate: create sequence MEMBER_SEQ start with 1 increment by 1

==========
Hibernate:
    call next value for MEMBER_SEQ
member Id : 1
==========
Hibernate:
    /* insert hellojpa.Member
        */ insert
        into
            Member
            (name, id)
        values
            (?, ?)

em.persist에 담고, @GeneratedValue(strategy = GenerationType.SEQUENCE)를 확인하면
DB에서 가져와야하기에 먼저 member의 id 값을 가져온다
그리고 commit 시점에 insert를 실행한다.

성능부분에서 고민되는 부분은 계속 네트워크를 갔다와야하는 부분에 문제가 있을 수 있다 생각된다.
(예 : 
    em.persist(member1)
    em.persist(member2)
    em.persist(member3)
)
그래서
@SequenceGenerator(
    name = "MEMBER_SEQ_GENERATOR",
    sequenceName = "MEMBER_SEQ",
    initialValue = 1, allocationSize = 50
)

* allocationSize 값을 50으로 준다.
* DB는 51번으로 세팅하고 메모리에서 1씩 준다

Hibernate: create sequence MEMBER_SEQ1 start with 1 increment by 50

* 첫번째 실행
  ==========
  Hibernate:
  call next value for MEMBER_SEQ1
  Hibernate:
  call next value for MEMBER_SEQ1
  member Id 1 : 1
  member Id 2 : 2
  member Id 3 : 3
  ==========

* 두번째 실행
  ==========
  Hibernate:
  call next value for MEMBER_SEQ1
  member Id 1 : 52
  member Id 2 : 53
  member Id 3 : 54
  ==========


* 세번째 실행
  ==========
  Hibernate:
  call next value for MEMBER_SEQ1
  member Id 1 : 102
  member Id 2 : 103
  member Id 3 : 104
  ==========
##### allocationSize
결과적으로
첫번째 데이터가 없을 경우 call next value for MEMBER_SEQ1을 두번 실행하는데,
DB에 sequence를 확인해서 처음에는 1, 두번째는 51을 조회한다
유무를 판단해서 첫 실행에서는 1번부터 시퀀스를 주지만
두번째 세번째에서는 51을 확인하고 세번째는 101을 확인한다.
allocationSize에 값을 넣어준 50을 배수로 확인한다.
그렇게 첫번째 시퀀스를 확인하고 persist(member)를 지속적으로 50개 넣어야한다면,
51번 부터 50개가 저장이 된다.

이러한 방법으로 계속해서 통신해야한다는 부담감을 덜어 낼 수 있고 동시성 문제까지 해결할 수 있다.

그래서 allocationSize를 50이 아닌 10000 이상으로 넣고 편하게 하고 싶지만,
배포 등 어플리케이션을 종료하면 Size는 초기화되서 문제가 될 수 있기에 30~50이 적당하다.
