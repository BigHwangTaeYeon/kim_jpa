### 프록시와연관관계관리

- 프록시
- 즉시 로딩과 지연 로딩
- 지연 로딩 활용
- 영속성 전이 : CASCADE
- 고아 객체
- 영속성 전이 + 고아 객체, 생명주기

##### 프록시 기초
- em.find() vs em.getReference()    참조를 가져오는 메서드
- em.find() : 데이터베이스를 통해 실제 엔티티 객체 조회
- em.getReference() :  데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회

```java
Member findMember = em.getReference(Member.class, member.getId());
System.out.println("findMember = "  + findMember.getUserName());
```
Member findMember = em.getReference(Member.class, member.getId());
위 시점에서는 담기만 하고, 가져올 필요는 없기 때문에 select가 실행하지 않고
System.out.println("findMember = "  + findMember.getUserName());
위 시점에서는 username을 가져와야 하기 때문에 select를 실행한다.

findMember.getClass()를 찍어보면
class hellojpa.Member$HibernateProxy$Da1zEKh3가 나온다.
Hibernate가 강제로 만든 프록시 객체이다.

- 실제 클래스를 상속 받아서 만들어진다.
- 실제 클래스와 겉 모양이 같다.
- 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 된다.(이론상)

프록시 객체 초기화
getReference()의 getName을 요청하면 값이 없기 때문에
MemberProxy 객체의 Member target 값은 영속성 컨텍스트에 요청하게 된다.
    그러면 영속성 컨텍스트에서 DB 조회를 통해 Member를 가져오고
    target에 조회한 Member를 연결해준다.

##### 프록시의 특징
• 프록시 객체는 처음 사용할 때 한 번만 초기화
• 프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아님, 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근 가능
    System.out.println("beafore " + findMember2.getClass());
    System.out.println("after " + findMember2.getClass());
    *** 동일하게 hellojpa.Member$HibernateProxy$Da1zEKh3 프록시로 나온다 ***
• 프록시 객체는 원본 엔티티를 상속받음, 따라서 타입 체크시 주의해야함 (== 비교 실패, 대신 instance of 사용)
    프록시가 실제 엔티티로 바뀌는 것이 아니기 때문에 주의 해야한다 ! (절대 ==을 사용하면 안된다. findMember instanceof Member)
• 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티 반환
    만약 em.find()로 찾아주고 em.getReference()를 실행하면
    ```java
    Member findMember1 = em.find(Member.class, member.getId());
    Member findMember2 = em.getReference(Member.class, member.getId());
    System.out.println("m1 : " + findMember1.getClass());
    System.out.println("m2 : " + findMember2.getClass());
    System.out.println("m1 == m2 : " + (findMember1 == findMember2));
    ```
    m1 : class hellojpa.Member
    m2 : class hellojpa.Member
    m2는 영속성 컨텍스트에 저장된 것을 가져온다.
    그래서 == 비교에서 true를 보장해준다.

    반대로
    ```java
    Member findMember2 = em.getReference(Member.class, member.getId());
    Member findMember1 = em.find(Member.class, member.getId());
    System.out.println("m1 : " + findMember1.getClass());
    System.out.println("m2 : " + findMember2.getClass());
    System.out.println("m1 == m2 : " + (findMember1 == findMember2));
    ```
    getReference()를 먼저 실행하면 find()로도 프록시가 나온다.
    JPA에서 true를 보장하기 때문에 이미 조회된 프록시 값을 가져온다.
• 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화하면 문제 발생
(하이버네이트는 org.hibernate.LazyInitializationException 예외를 터트림)
    프록시로 초기화를 해주고
    em.detach(findMember);  - 영속성 컨텍스트에서 더이상 관여 하지 않음
    이후 findMember2.getUserName();로 호출해주면
    org.hibernate.LazyInitializationException: could not initialize proxy [hellojpa.Member#1] - no Session
    위와 같은 오류 메시지가 나온다.
    detach()로 영속성 컨텍스트에 아무것도 담겨있지 않기에 가져올 수가 없는 것이다.
    em.clear()도 동일하다.
    
    org.hibernate.LazyInitializationException 이 Exception을 기억하자

##### 프록시 확인
- 프록시 인스턴스의 초기화 여부 확인
    PersistenceUnitUtil.isLoaded(Object entity)
    emf = Persistence.createEntityManagerFactory("hello");
    System.out.println("isLoaded = " + emf.getPersistenceUnitUtil().isLoaded(findMember2));
    findMember2.getUserName();
    System.out.println("isLoaded = " + emf.getPersistenceUnitUtil().isLoaded(findMember2));
        첫번째는 false 두번째는 true
- 프록시 클래스 확인 방법
    entity.getClass().getName() 출력
    (..javasist.. or HibernateProxy...)
- 프록시 강제 초기화
    org.hibernate.Hibernate.initialize(entity); 
    System.out.println("isLoaded = " + emf.getPersistenceUnitUtil().isLoaded(findMember2));
    Hibernate.initialize(findMember2);
    System.out.println("isLoaded = " + emf.getPersistenceUnitUtil().isLoaded(findMember2));
    JPA에서는 강제 초기화가 없기에 Hibernate에서 제공하는 method를 사용해야 한다.
- 참고 : JPA 표준은 강제 초기화 없음
    강제 호출 : member.getName();







































